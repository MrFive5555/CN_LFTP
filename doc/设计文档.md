# 报文头格式
- 序号(seq, 32b)：表示传输的分组的开始序号
- 确认号(ack, 32b)：确认累积收到的字节序号（注意：ack所指向的一个Byte仍然未接收），或者说是期待下一个收到分组的seq
- 接受窗口长度(rwnd, 16b): 表示接收方可用的接收缓存大小
- 同步位(SYN, 1b): 发起连接请求时使用
- 确认位(ACK, 1b): 用于确认连接或确认断开
- 结束位(FIN, 1b): 发起断开请求时使用
- 资源位(SRC, 1b): 表示资源是否被发现，用于表明服务器是否有客户端所请求的文件
- 拒绝位(REJ, 1b): 表示非法请求，服务器拒绝服务
- 未用(11b)
报文头共固定长度12B。有效载荷的长度为UDP包有效载荷的长度减去报文头的长度。

# 协议设计
## 连接建立与关闭
LFTP使用与TCP相类似的三次握手四次挥手机制进行连接的建立与中断。在第三次握手时，客户端告诉服务端自己是需要上传还是下载文件。需要传输的一方开始建立连接状态的信息，分配变量。  
当发送方发送文件完毕后，将对接收方发送一个FIN的请求，接收方收到后，关闭连接，并回复一个FIN ACK的回复报文，表示允许断开，此时发送方关闭连接，清理连接变量。

## 架构设置
文件传输的两方是一种几乎对称的架构，各自设置三个线程：一个用于监听发送至socket的报文段，一个用于处理到达的报文段，另一个用于计时，进行超时控制。  
由于客户端在同一时刻只能与一个服务端连接，所以接收报文与处理报文的线程合并成一个。  

## 多用户
进行LFTP连接的两方都会维护一个connection的表，表里每一项都记录一个连接，使用对方的地址（IP地址和端口号）作为表元素的键。当报文到达后，使用地址找到connection表中找到对应的连接，交付给路由进行处理

## 连接状态
连接在某一时刻连接可能会有三种传输层状态：未建立、待连接、活跃。
- 未建立（UNESTABLISH）：连接未建立，所有尝试交换数据的连接都会被拒绝额
- 待连接（WAIT_CONNECT）:等待连接建立，为客户端已发送第一次握手报文或客户端已发送第二次握手报文时的状态
- 活跃（ACTIVE）：完成三次握手后，客户端和服务端都进入活跃状态，活跃状态下，链接还会有三种状态应用层状态（LFTP状态）
LFTP可能有三种状态：lset，lget，wait_confirm
- lsent：代表发送方
- lget：代表接收方
- wait_confirm：未知LFTP状态，为服务端完成第二次握手后，等待客户端告知连接类型

## 路由(route)
在LFTP中，路由的作用是根据连接的状态对报文进行正确的回复。路由分两层：
- 第一层：拒绝非法操作，处理FIN请求，处理第一次握手的连接请求
- 第二层：在WAIT_CONNECT状态下，处理第二、三次握手，激活状态；在ACTIVE状态下，判断是接收方还是发送方

## 线程通信
监听线程使用一个队列(mailbox)给处理线程传递消息，处理线程阻塞式地从mailbox中获取消息并处理。处理线程与超时管理线程需要共享connection表（因此需要进行线程同步）。三个线程之间信息交换的方式如下表所示，左边的列表示信息的来源，右边的行表示信息的目的地。
||接收线程|处理线程|超时管理线程|
|:-:|:-:|:-:|:-:|
|接收线程|－|mailbox|无
|处理线程|无|－|共享connection
|超时管理线程|无|共享connection|－

## 线程同步
我们把对connection表访问的互斥锁的获取和释放功能都放在route中，因为所有报文段的接受过程都会完成整个route阶段，因此在route中对互斥锁进行操作不会出现死锁。  
同样的，在超时管理线程中在处理函数的出口和入口进行加锁和解锁操作，可以避免出现思索，同时保证对connection的访问能够互斥进行。

# 变量维护
## 常量
- MSS: 最大发送数据包长
- MAX_BUFFER_ITEM: 缓冲区能存放的最大报文数
- SAMPLE_INTERVAL: 测试RTT的间隔
- MAX_TIMEOUT_COUNT: 最大超时次数，如果超过这个超时次数将自动断开连接

## 连接状态
- connectionTable: 服务器端一张连接表: 表中的每一项都记录了一个主机地址和端口号，连接状态，连接信息，上一次活跃时间
- MAX_TIMEOUT_COUNT: 最大超时次数。如果与对方连接中超时的此时超过这个次数，连接将被中断。
- server_isn: 服务器选择的初始序号
- client_isn: 客户端选择的初始序号
- type: 表示接收方或发送方
- path: 待传输文件的名称
- file: 打开的文件句柄
- ctl: 控制变量
- timer: 计时器变量

## 传输相关
**流控制相关**
- LastByteSent: 最后一个发送的字节（不包括边界）
- LastByteAck: 最后一个被确认的字节（不包括边界）
- LastByteRecv: 上一个接受的字节（不包括边界）
- waitACK: 队列，队列中的每个元素为已发送的一个分组需要得到的确认号
- buffer: 数组，记录待发送的数据及这些数据的序号

**拥塞控制相关**
- cwnd: 传输控制窗口
- rwnd: 接收窗口

**超时间隔相关**
- EstimatedRTT: 估计的RTT值
- DevRTT: RTT估计值与真实值之间（估计的）上限
- TimeoutInterval: 超时间隔
- SampleACK: 需要测量RTT的包
- sendSampleTime: SampleACK的包发出去的时刻
- lastSampleTime: 上一次完成SampleRTT测量的时间
- isSampling: 传输端是否正在等待样本回复
- SAMPELE_INTERVAL: 测量RTT的时间间隔
- leaveTime: 数组，数组元素记录的是对应连接距离下一次超时的时间
- lastDatagramSent: 上次发送的数据包
- timeoutCount: 已经超时的次数

# 运行机制

## 流控制
发送方发出分组头部会带有seq信息，表示发送分组载荷中文件的位置，接收方根据seq中的信息把各个分组重新拼接成完整的文件。接收方接受分组后，在回复的分组中会把头部的ack字段设置成累计确认的数据（或者说是下一个等待接受的seq号）。

## 发送新的包
```
# 可发送字节数
waitLen = min{cwnd, rwnd} - (LastByteSend-LastByteAck)
# 把这些字节划分为N个大小不超过MSS的包
N = waitLen / MSS
# 确定划分分界点
split = splitToPiece(waitLen, N)
# 放入waitACK
waitACK.append(split)
# 发送数据包
send(piece)
# 更新LastByteSend
LastByteSend += waitLen
```

## 重传
重传LastByteACK到waitACK.head()之间的这一段数据

## 拥塞控制
状态转移表
||超时|三个冗余ACK|新ACK|
|:-:|:-:|:-:|:-:|
|慢启动|慢启动|快速恢复|慢启动／拥塞避免
|拥塞避免|慢启动|快速恢复|拥塞避免
|快速恢复|慢启动|快速恢复|拥塞避免

## 超时检测
发送方可能需要同时传输给若干用户（多个客户端同时在服务端下载文件时）。这时候发送放需要同时维护多个传输的超时控制器。但多个计时器会给系统带来极大的负担，因此我们只设定一个计时器，只为最近要超时的发送方计时，其他各个连接只保留一个超时的剩余时间。

## 超时间隔设置
每经过一个SAMPELE_INTERVAL，传输方会开始记录一个样本分组的发送时间。如果这个分组在下一次丢包时间发生之前到达，那么返回时间与发送时间sendSampleTime之间的时间就是SampleRTT。若等待这个包返回的过程中出现丢包，那么将取消这次测量，并以下一个发送的分组作为样本分组测量sampleRTT。得到sampleRTT的值后，传输方将更新EstimatedRTT, DevRTT的值，并用这些值更新TimeoutInterval  
当超时事件发生时，发送方将暂时使用当前TimeInterval的两倍作为新的TimeoutInterval。直到网络能重新连接后，再重新设回原来的TimeoutInterval, 并进行新的sampleRTT测量